function calculate_next_move with board, turn, permutations do
  set move to calculate_next_move_win(board, turn, permutations)
  if move != false do
    return move
  end

  change move to calculate_next_move_block(board, turn, permutations)
  if move != false do
    return move
  end
  return calculate_next_move_valid(board)
end

function calculate_next_move_win with board, turn, permutations do
  for each row in [1,2,3] do
    for each col in [1,2,3] do
      if board[row][col] == "" do
        change board[row][col] to turn
        for each permutation in permutations do
          if has_won(board, permutation, turn) do
            return [row, col]
          end
        end
        change board[row][col] to ""
      end
    end
  end
  return false
end

function calculate_next_move_block with board, turn, permutations do
  change turn to switch_turn(turn)
  return calculate_next_move_win(board, turn, permutations)
end

function calculate_next_move_valid with board do
  for each row in [1,2,3] do
    for each col in [1,2,3] do
      if board[row][col] == "" do
        return [row, col]
      end
    end
  end
end

function draw_grid do
  change_stroke(1, "#333333")
  rectangle(5, 5, 90, 90, "#ffffff")
  line(5, 35, 95, 35, "#000000")
  line(5, 65, 95, 65, "#000000")
  line(35, 5, 35, 95, "#000000")
  line(65, 5, 65, 95, "#000000")
end

function draw_cross with row, col, color do
  set cx to -10 + (col * 30)
  set cy to -10 + (row * 30)

  line(cx - 10, cy - 10, cx + 10, cy + 10, color)
  line(cx - 10, cy + 10, cx + 10, cy - 10, color)
end

function draw_naught with row, col, color do
  circle(-10 + (col * 30), -10 + (row * 30), 10, color)
end

function draw_piece with turn, row, col, color do
  if turn == "x" do
    draw_cross(row, col, color)
  else do
    draw_naught(row, col, color)
  end
end

function has_won with board, permutation, target do
  set cell1 to board[permutation[1][1]][permutation[1][2]]
  set cell2 to board[permutation[2][1]][permutation[2][2]]
  set cell3 to board[permutation[3][1]][permutation[3][2]]
  return cell1 == target and cell1 == cell2 and cell2 == cell3
end

function grey_out with board do
  change_stroke(1, "#cccccc")

  for each row in [1,2,3] do
    for each col in [1,2,3] do
      if board[row][col] != "" do
        draw_piece(board[row][col], row, col, "#cccccc")
      end
    end
  end
end

function handle_win with board, permutation, winner do
  grey_out(board)

  change_stroke(1.5, "#604fcd")
  for each cell in permutation do
    draw_piece(winner, cell[1], cell[2], "#604fcd")
  end

  rectangle(0, 0, 100, 100, "#604fcd")
  write(concatenate("The ", winner, "'s won!"))
end

function handle_draw with board do
  grey_out(board)
  rectangle(0, 0, 100, 100, "#604fcd")
  write("The game was a draw!")
end

function guard_move_allowed with board, row, col do
  if board[row][col] == "" do
    return true
  end

  rectangle(0, 0, 100, 100, "#c80000")
  write("Invalid move!")

  return false
end

function switch_turn with turn do
  if turn == "o" do
    return "x"
  else do
    return "o"
  end
end

function run_game with moves do
  set board to [["","",""], ["","",""], ["","",""]]
  set permutations to [
    [[1,1],[1,2],[1,3]],
    [[2,1],[2,2],[2,3]],
    [[3,1],[3,2],[3,3]],
    [[1,1],[2,1],[3,1]],
    [[1,2],[2,2],[3,2]],
    [[1,3],[2,3],[3,3]],
    [[1,1],[2,2],[3,3]],
    [[1,3],[2,2],[3,1]]
  ]
  draw_grid()

  set turn to "x"
  set row to 0
  set col to 0
  set num_moves to 0

  for each move in moves do
    change num_moves to num_moves + 1
    change turn to switch_turn(turn)

    if(move == "?") do
      change move to calculate_next_move(board, turn, permutations)
    end

    change row to move[1]
    change col to move[2]

    if !guard_move_allowed(board, row, col) do
      return
    end

    change board[row][col] to turn
    draw_piece(turn, row, col, "#ffffff")

    for each permutation in permutations do
      if has_won(board, permutation, turn) do
        handle_win(board, permutation, turn)
        return
      end
    end

    if num_moves == 9 do
      handle_draw(board)
      return
    end
  end
end
